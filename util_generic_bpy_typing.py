from typing import TYPE_CHECKING

"""This module allows for using generic bpy_prop, bpy_prop_collection, bpy_prop_collection_idprop and bpy_prop_array
in type hints. The classes exported by this module should ONLY be used for static type-checking, they will mot have
the correct values at runtime (but will be correct enough to not raise errors when used in type hints)"""

# TYPE_CHECKING is False at runtime
if TYPE_CHECKING:
    # These classes do not exist in bpy.types, they are only a part of the bpy.types stubs generated by
    # https://github.com/Mysteryem/pycharm-blender which I am using to assist with static type-checking
    # noinspection PyProtectedMember,PyPep8Naming
    from bpy.types import (
        _generic_prop as Prop,
        _generic_prop_collection as PropCollection,
        _generic_prop_array as PropArray,
        _generic_prop_collection_idprop as PropCollectionIdProp,
    )
else:
    from bpy.types import bpy_prop, bpy_prop_collection, bpy_prop_array
    # Module import to avoid cyclic dependency in the case that utils wants to import specific attributes from this
    # module directly
    from . import utils

    # I would just set each attribute to 'type', since it can be subscripted with any combination to produce a
    # types.GenericAlias, but PyCharm doesn't like it for some reason and claims it can't find '[' when subscripting

    # Create a dummy class that returns its type argument when subscripted
    #
    # Could create a subclass of the dummied class (and override __class_getitem__), but I'm not sure if it's a good
    # idea to be creating subclasses
    class _GenericDummy:
        def __init__(self, dummied_type: type): self._dummied_type = dummied_type
        def __getitem__(self, _item): return self._dummied_type
        # To allow for isinstance and issubclass checks:
        # def __instancecheck__(self, instance): return self._dummied_type.__instancecheck__(instance)
        # def __subclasscheck__(self, subclass): return self._dummied_type.__subclasscheck__(subclass)
        # To allow for comparison:
        # def __eq__(self, other): return self._dummied_type == other
        # To allow for getting attributes (other than '_dummied_type'):
        # def __getattr__(self, item): return getattr(self._dummied_type, item)

    Prop = _GenericDummy(bpy_prop)
    PropCollection = _GenericDummy(bpy_prop_collection)
    PropArray = _GenericDummy(bpy_prop_array)
    PropCollectionIdProp = _GenericDummy(utils.PropCollectionType)

__all__ = [
    'Prop',
    'PropCollection',
    'PropArray',
    'PropCollectionIdProp',
]
