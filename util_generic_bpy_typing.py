from typing import TYPE_CHECKING

"""This module allows for using generic bpy_prop, bpy_prop_collection, bpy_prop_collection_idprop and bpy_prop_array
in type hints. The classes exported by this module should ONLY be used for static type-checking, they will mot have
the correct values at runtime (but will be correct enough to not raise errors when used in type hints)"""

# TYPE_CHECKING is False at runtime
if TYPE_CHECKING:
    # These classes do not exist in bpy.types, they are only a part of the bpy.types stubs generated by
    # https://github.com/Mysteryem/pycharm-blender which I am using to assist with static type-checking
    # noinspection PyProtectedMember,PyPep8Naming
    from bpy.types import (
        _generic_prop as Prop,
        _generic_prop_collection as PropCollection,
        _generic_prop_array as PropArray,
        _generic_prop_collection_idprop as PropCollectionIdProp,
    )
else:
    from bpy.types import bpy_prop, bpy_prop_collection, bpy_prop_array
    # Module import to avoid cyclic dependency in the case that utils wants to import specific attributes from this
    # module directly
    from . import utils

    # I would just set each attribute to 'type', since it can be subscripted with any combination to produce a
    # types.GenericAlias, but PyCharm doesn't like it for some reason and claims it can't find '[' when subscripting

    # Create a dummy class that returns its type argument when subscripted
    #
    # Could create a subclass of the dummied class (and override __class_getitem__), but I'm not sure if it's a good
    # idea to be creating subclasses
    def _make_dummy(t: type):
        class _GenericDummy:
            def __class_getitem__(cls, item): return t
            # To allow for isinstance and issubclass checks:
            # def __instancecheck__(self, instance): return t.__instancecheck__(instance)
            # def __subclasscheck__(self, subclass): return t.__subclasscheck__(subclass)
            # To allow for comparison:
            # def __eq__(self, other): return t == other
            # To allow for getting attributes:
            # def __getattr__(self, item): return getattr(t, item)
        return _GenericDummy

    Prop = _make_dummy(bpy_prop)
    PropCollection = _make_dummy(bpy_prop_collection)
    PropArray = _make_dummy(bpy_prop_array)
    PropCollectionIdProp = _make_dummy(utils.PropCollectionType)

__all__ = [
    'Prop',
    'PropCollection',
    'PropArray',
    'PropCollectionIdProp',
]
